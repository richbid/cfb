/* This class framework is generated by Core Frame Builder. */
/* For more information, refer to http://www.one-lab.net/ */

/* Data Handling Class */
#include "cls.h"
inline bool qtns::cls::compare_to(cls& aValue) const {
	if (mPBool != aValue.getPBool()) return false;
	if (mPBytes != aValue.getPBytes()) return false;
	if (mPDate != aValue.getPDate()) return false;
	if (mPDateTime != aValue.getPDateTime()) return false;
	if (mPDouble != aValue.getPDouble()) return false;
	if (mPFloat != aValue.getPFloat()) return false;
	if (mPInt32 != aValue.getPInt32()) return false;
	if (mPText != aValue.getPText()) return false;
	if (mPTime != aValue.getPTime()) return false;
	if (mPUInt32 != aValue.getPUInt32()) return false;
	if (mPCls0 != aValue.getPCls0()) return false;
	return true;
}

inline void qtns::cls::clone_from(cls& aValue) {
	setPBool(aValue.getPBool());
	setPBytes(aValue.getPBytes());
	setPDate(aValue.getPDate());
	setPDateTime(aValue.getPDateTime());
	setPDouble(aValue.getPDouble());
	setPFloat(aValue.getPFloat());
	setPInt32(aValue.getPInt32());
	setPText(aValue.getPText());
	setPTime(aValue.getPTime());
	setPUInt32(aValue.getPUInt32());
	setPCls0(aValue.getPCls0());
}

qtns::cls::~cls() {
}

qtns::cls::cls() {
	mPBool = false;
	mPDouble = 0.0;
	mPFloat = 0.0f;
	mPInt32 = 0;
	mPUInt32 = 0u;
}

qtns::cls::cls(const bool& aPBool, const onelab::Bytes& aPBytes, const QDate& aPDate, const QDateTime& aPDateTime, const double& aPDouble, const float& aPFloat, const int& aPInt32, const QString& aPText, const QTime& aPTime, const unsigned int& aPUInt32, ns::cls0* aPCls0){
	setPBool(aPBool);
	setPBytes(aPBytes);
	setPDate(aPDate);
	setPDateTime(aPDateTime);
	setPDouble(aPDouble);
	setPFloat(aPFloat);
	setPInt32(aPInt32);
	setPText(aPText);
	setPTime(aPTime);
	setPUInt32(aPUInt32);
	setPCls0(aPCls0);
}

void qtns::cls::_invoke_(const QString& entry, const QString& input, QString& output) {
	if (false){}
}
int qtns::cls::field_count() {
	return 11;
}

int qtns::cls::validate_field(int index, const QVariant& value) {
	return input_field(index, value, false);
}

int qtns::cls::validate_field(const QString& key, const QVariant& value) {
	return input_field(key, value, false);
}

const QString field_keys[] = { "PBool", "PBytes", "PDate", "PDateTime", "PDouble", "PFloat", "PInt32", "PText", "PTime", "PUInt32", "PCls0",  };

int qtns::cls::input_field(int index, const QVariant& value, bool _set_value) {
	if (index < 0 || index > (field_count()-1)) return 0;
	return input_field(field_keys[index], value, _set_value);
}

int qtns::cls::input_field(const QString& key, const QVariant& value, bool _set_value) {
	int result = 0;
	if (!key.length()) return 0;
	else if (key == "PBool") {
		if (_set_value) {
			bool v = value.toBool();
			setPBool(v);
		}
		result = 1;
	}
	else if (key == "PBytes") {
		if (_set_value) {
			onelab::Bytes v(value.toString());
			setPBytes(v);
		}
		result = 1;
	}
	else if (key == "PDate") {
		if (_set_value) {
			QDate v = value.toDate();
			setPDate(v);
		}
		result = 1;
	}
	else if (key == "PDateTime") {
		if (_set_value) {
			QDateTime v = value.toDateTime();
			setPDateTime(v);
		}
		result = 1;
	}
	else if (key == "PDouble") {
		if (_set_value) {
			double v = value.toDouble();
			setPDouble(v);
		}
		result = 1;
	}
	else if (key == "PFloat") {
		if (_set_value) {
			float v = value.toFloat();
			setPFloat(v);
		}
		result = 1;
	}
	else if (key == "PInt32") {
		if (_set_value) {
			int v = value.toInt();
			setPInt32(v);
		}
		result = 1;
	}
	else if (key == "PText") {
		if (_set_value) {
			QString v = value.toString();
			setPText(v);
		}
		result = 1;
	}
	else if (key == "PTime") {
		if (_set_value) {
			QTime v = value.toTime();
			setPTime(v);
		}
		result = 1;
	}
	else if (key == "PUInt32") {
		if (_set_value) {
			unsigned int v = value.toUInt();
			setPUInt32(v);
		}
		result = 1;
	}
	else if (key == "PCls0") {
		if (_set_value) {
			if (getPCls0()) { return getPCls0()->from_json(value.toString()); }
		}
		result = 1;
	}
	return result;
}

inline bool qtns::clsList::compare_to(clsList& aValue) const {
	if (Items.count() != aValue.Items.count()) return false;
	for (int n = 0; n < Items.count(); n++) if (Items[n] != aValue.Items[n]) return false;
	return true;
}

int qtns::cls::to_json(QString& output) {
	QString jsonPCls0;
	if (mPCls0)
		if (mPCls0->to_json(jsonPCls0) != 1) return 0;
	output = QString("{") + "\"PBool\"" + ":" + "\"" + to_string(getPBool()) + "\"" + "," + "\"PBytes\"" + ":" + "\"" + mPBytes.toString() + "\"" + "," + "\"PDate\"" + ":" + "\"" + mPDate.toString("yyyy/MM/dd") + "\"" + "," + "\"PDateTime\"" + ":" + "\"" + mPDateTime.toString("yyyy/MM/dd HH:mm:ss.zzz") + "\"" + "," + "\"PDouble\"" + ":" + "\"" + to_string(getPDouble()) + "\"" + "," + "\"PFloat\"" + ":" + "\"" + to_string(getPFloat()) + "\"" + "," + "\"PInt32\"" + ":" + "\"" + to_string(getPInt32()) + "\"" + "," + "\"PText\"" + ":" + "\"" + mPText + "\"" + "," + "\"PTime\"" + ":" + "\"" + mPTime.toString("HH:mm:ss.zzz") + "\"" + "," + "\"PUInt32\"" + ":" + "\"" + to_string(getPUInt32()) + "\"" + "," + "\"PCls0\"" + ":" + jsonPCls0 + "}";
	return 1;
}

int qtns::clsList::to_json(QString& output, const QString& tag) {
	if (!tag.length()) return 0;
	QStringList list;
	QString text;
	foreach(cls item, Items) {
		item.to_json(text);
		list += text;
	}
	output = "{\"" + tag + "\":[" + list.join(",") + "]}";
	return 1;
}

int qtns::cls::from_json(const QMap<QString, QVariant>& map) {
	if (map.count() != field_count()) return 0;
	foreach(QString key, map.keys())
		if (!validate_field(key, map[key])) return 0;
	foreach(QString key, map.keys())
		input_field(key, map[key], true);
	return 1;
}

int qtns::cls::from_json(const QString& input) {
	if (!input.length()) return 0;
	QJson json;
	QVariant variant = json.decode(input);
	if (variant.type () == QVariant::Map) {
		QMap<QString, QVariant> map = variant.toMap();
		return from_json(map);
	}
	return 0;
}

int qtns::clsList::from_json(const QString& input, const QString& tag) {
		if (!input.length() || !tag.length()) return 0;
		QJson json;
		QVariant variant = json.decode(input);
		if (variant.type() != QVariant::Map) return 0;
		QMap<QString, QVariant> map = variant.toMap();
		if (!map.count() || map.keys()[0] != tag)
				return 0;
		QList<QVariant> list = map.values()[0].toList();
		if (!list.count()) return 0;
		QList<cls> newList;
		cls cls;
		foreach(variant, list) {
			QMap<QString, QVariant> map = variant.toMap();
			if (!cls.from_json(map))
					return 0;
			newList << cls;
		}
		Items.clear();
		Items = newList;
		return 1;
	return 0;
}
